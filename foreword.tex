%!TEX root = ts.tex

\chapter{Introduction}
\label{chp:Introduction}

We propose RCU for inclusion into C++26.
This paper contains proposed rationale to support RCU into C++26 as
well as the interface and wording for RCU, a technique for safe deferred
reclamation.
We further propose that the wording in Section~\ref{saferecl.rcu}
be adopted as a new ``Safe reclamation'' chapter of the IS, and we
anticipate that hazard pointers would be covered by another section of
this same chapter.

The purpose of adding RCU to the IS is to provide a small number of
known-good implementations of RCU in standard libraries.
RCU is easy to get wrong, and one purpose standard libraries is to
provide good implementations of things that are easy to get wrong.

\section{Proposed Entry to C++26 IS}
\label{sec:Proposed Entry to C++26 IS}

A near-superset of this proposal is implemented in the Folly RCU library.
This library has used in production for several years, so we have good
implementation experience for the proposed variant of RCU.

This proposal is identical to that in Concurrency TS 2.
We expect that the proposal in Concurrency TS 2 will change over
time, for example, adding some of the features that are present in
the Folly RCU library or in the Linux kernel.
Such features might include:

\begin{enumerate}
\item	Multiple RCU domains.
	For example, SRCU provides these in the Linux kernel.
	However, RCU was in the Linux for four years before
	this was needed, so it is not in this proposal for C++26.
\item	Special-purpose RCU implementations.
	For example, the Linux kernel has specialized implementations
	for preemptible environments, single-CPU systems,
	as well as three additional implementations required by
	the Linux kernel's tracing and extended Berkeley Packet
	Filter (eBPF) use cases.
	However, none of these seem applicable to userspace applications,
	so none of them are in this proposal for C++26.
\item	Polling grace-period-wait APIs.
	These allow non-blocking algorithms to interface with RCU
	grace periods, for example, in the Linux kernel, they allow
	NMI handlers to do RCU updates.
	(NMI handlers could do RCU readers from the get-go.)
	However, RCU was in the Linux kernel for more than a decade before
	such APIs were needed, so they are not in this proposal for C++26.
\item	Async-friendly APIs for RCU's blocking APIs.
	These might leverage the aforementioned polling APIs.
	However, more work is required to determine exactly what support
	is required, so they are not in this proposal for C++26.
\item	A free function similar to \tcode{rcu_retire} that uses
	an \tcode{rcu_obj_base} if available, but which invokes
	\tcode{rcu_retire} if not.
	(Suggested by Tomasz Kami\'{n}ski.)
	However, this facility has not yet been spotted in the wild,
	so it is not in this proposal for C++26.
\item	A memory allocator might be supplied for the use of
	\tcode{rcu_retire}.
	Please note that if different allocators can be supplied to
	different calls to \tcode{rcu_retire}, then there must be a way
	to tag the allocated memory with the corresponding deleter.
	However, this facility has not yet been spotted in the wild,
	so it is not in this proposal for C++26.
\item	Numerous efficiency-oriented APIs.
	For but one example, the Linux kernel has an alternative
	\tcode{rcu_access_pointer()} that can be used in place
	of \tcode{rcu_dereference()} (Linux-kernelese for ``consume load'')
	when the resulting pointer will not be dereferenced
	(for example, when it is only going to be compared to \tcode{NULL}).
	But it is not clear which (if any) of these would be accepted
	into the Linux kernel today, given the properties of modern
	computer hardware.
	Therefore, these are not in this proposal for C++26.
\end{enumerate}

The snapshot library described in P0561R5 (``RAII Interface for Deferred
Reclamation'') provides an easy-to-use deferred-reclamation facility
applying only to a single object which is intended to be based upon
either RCU or Hazard Pointers.
It cannot replace either RCU or Hazard Pointers.

\begin{table*}
\renewcommand*{\arraystretch}{1.25}
\footnotesize
\centering
\begin{tabular}{l|lll}
	Property
		& Reference Counting
			& Hazard Pointers
				& RCU \\
%		  RC	  HP	  RCU \\
	\hline
	\hline
	Readers
		& Slow and unscalable
			& \emph{Fast and scalable}
				& \emph{Fast and scalable} \\
	\hline
	Unreclaimed Objects
		& \emph{Bounded}
			& \emph{Bounded}
				& Unbounded \\
%	\hline
%	Protection Duration
%		& Can be long
%			& Can be long
%				& Must bound duration \\
	\hline
	Traversal Retries?
		& If object deleted
			& If object deleted
				& \emph{Never} \\
	\hline
	Reclamation latency?
		& \emph{Fast}
			& Slow
				& Slow \\
\end{tabular}
\caption{High-Level Comparison of Deferred-Reclamation Techniques}
\label{tab:High-Level Comparison of Deferred-Reclamation Techniques}
\end{table*}

The Hazard Pointers library described in D2530R0 (``Why Hazard Pointers
Should Be in C++26'').
As a very rough rule of thumb, Hazard Pointers can be considered to be
a scalable replacement for reference counters and RCU can be considered
to be a scalable replacement for reader-writer locking.
A high-level comparison of reference counting, Hazard Pointers, and RCU
is displayed in
Table~\ref{tab:High-Level Comparison of Deferred-Reclamation Techniques}.

Note that we are making this working paper available before Concurrency
TS2 been published, which some might feel is unconventional.
On the other hand, Paul was asked to begin this effort in 2014, it is now
2022, and C++ implementations have been used in production for some time,
perhaps most notably the Folly RCU library.

\section{Feature-Test Macro}
\label{sec:Feature-Test Macro}

We propose a new feature-test macro
\tcode{__cpp_lib_rcu} be added to Section~17.3.2 of the IS.

\section{Tony Tables}
\label{sec:Tony Tables}

Although RCU can be applied to a great many use cases, its most common
use case is as a replacement for reader-writer locking.
The reader-writer usage patterns most susceptible to conversion to RCU
are those where a value is computed while read-holding that lock, then
used after releasing that same lock.

\begin{table*}
\renewcommand*{\arraystretch}{1.25}
\footnotesize
\centering
\begin{tabular}{|l|l|}
	\hline
	With Reader-Writer Locking
		& With RCU in the intrusive style\\
%	rwlock  & RCU \\
	\hline
	\tcode{struct Data { /* members */ };}
		& \tcode{struct Data : std::rcu_obj_base<Data> { /* members */ };} \\
	\hline
	\tcode{Data* data_;}
		& \tcode{std::atomic<Data*> data_;} \\
	\tcode{std::shared_mutex m_;}
		& \\
	\hline
	\tcode{template <typename Func>}
		& \tcode{template <typename Func>} \\
	\tcode{Result reader_op(Func fn) \{}
		& \tcode{Result reader_op(Func fn) \{} \\
	\tcode{  std::shared_lock<std::shared_mutex> l(m_);}
		& \tcode{  std::scoped_lock l(std::rcu_default_domain());} \\
	\tcode{  Data* p = data_;}
		& \tcode{  Data* p = data_;} \\
	\tcode{  // fn should not block too long or call update()}
		& \tcode{  // fn should not block too long or call} \\
		& \tcode{  // rcu_synchronize(), rcu_barrier(), or} \\
		& \tcode{  // rcu_retire(), directly or indirectly} \\
	\tcode{  return fn(p);}
		& \tcode{  return fn(p);} \\
	\tcode{\}}
		& \tcode{\}} \\
	\hline
	\tcode{// May be called concurrently with reader_op}
		& \tcode{// May be called concurrently with reader_op} \\
	\tcode{void update(Data* newdata) \{}
		& \tcode{void update(Data* newdata) \{} \\
	\tcode{  Data* olddata;}
		& \tcode{  Data* olddata = data_.exchange(newdata);} \\
	\tcode{  \{}
		& \\
	~~\tcode{    std::unique_lock<std::shared_mutex> wlock(m_);}
		& \\
	~~\tcode{    olddata = std::exchange(data_, newdata);}
		& \\
	\tcode{  \}}
		& \\
	\tcode{  delete olddata; // reclaim *olddata immediately}
		& \tcode{  olddata->retire(); // reclaim *olddata when safe} \\
	\tcode{\}}
		& \tcode{\}} \\
	\hline
\end{tabular}
\caption{Tony Table for Reader-Writer Locking and Intrusive RCU}
\label{tab:Tony Table for Reader-Writer Locking and Intrusive RCU}
\end{table*}

Table~\ref{tab:Tony Table for Reader-Writer Locking and Intrusive RCU}
compares reader-writer locking and intrusive RCU, that is, when the
RCU-protected data items inherit from \tcode{std::rcu_obj_base<T>} and
use the \tcode{->retire()} member function.

\begin{table*}
\renewcommand*{\arraystretch}{1.25}
\footnotesize
\centering
\begin{tabular}{|l|l|}
	\hline
	With Reader-Writer Locking
		& With RCU in the non-intrusive style\\
%	rwlock  & RCU \\
	\hline
	\tcode{struct Data { /* members */ };}
		& \tcode{struct Data { /* members */ };} \\
	\hline
	\tcode{Data* data_;}
		& \tcode{std::atomic<Data*> data_;} \\
	\tcode{std::shared_mutex m_;}
		& \\
	\hline
	\tcode{template <typename Func>}
		& \tcode{template <typename Func>} \\
	\tcode{Result reader_op(Func fn) \{}
		& \tcode{Result reader_op(Func fn) \{} \\
	\tcode{  std::shared_lock<std::shared_mutex> l(m_);}
		& \tcode{  std::scoped_lock l(std::rcu_default_domain());} \\
	\tcode{  Data* p = data_;}
		& \tcode{  Data* p = data_;} \\
	\tcode{  // fn should not block too long or call update()}
		& \tcode{  // fn should not block too long or call} \\
		& \tcode{  // rcu_synchronize(), rcu_barrier(), or} \\
		& \tcode{  // rcu_retire(), directly or indirectly} \\
	\tcode{  return fn(p);}
		& \tcode{  return fn(p);} \\
	\tcode{\}}
		& \tcode{\}} \\
	\hline
	\tcode{// May be called concurrently with reader_op}
		& \tcode{// May be called concurrently with reader_op} \\
	\tcode{void update(Data* newdata) \{}
		& \tcode{void update(Data* newdata) \{} \\
	\tcode{  Data* olddata;}
		& \tcode{  Data* olddata = data_.exchange(newdata);} \\
	\tcode{  \{}
		& \\
	~~\tcode{    std::unique_lock<std::shared_mutex> wlock(m_);}
		& \\
	~~\tcode{    olddata = std::exchange(data_, newdata);}
		& \\
	\tcode{  \}}
		& \\
	\tcode{  delete olddata; // reclaim *olddata immediately}
		& \tcode{  std::rcu_retire(olddata); // reclaim *olddata when safe} \\
	\tcode{\}}
		& \tcode{\}} \\
	\hline
\end{tabular}
\caption{Tony Table for Reader-Writer Locking and Non-Intrusive RCU}
\label{tab:Tony Table for Reader-Writer Locking and Non-Intrusive RCU}
\end{table*}

Table~\ref{tab:Tony Table for Reader-Writer Locking and Non-Intrusive RCU}
compares reader-writer locking and non-intrusive RCU, that is, when the
RCU-protected data items do \emph{not} inherit from
\tcode{std::rcu_obj_base<T>} and instead use the \tcode{std::rcu_retire()}
free function.

\begin{table*}
\renewcommand*{\arraystretch}{1.25}
\footnotesize
\centering
\begin{tabular}{|l|l|}
	\hline
	With Reader-Writer Locking
		& With RCU in the synchronous style\\
%	rwlock  & RCU \\
	\hline
	\tcode{struct Data { /* members */ };}
		& \tcode{struct Data { /* members */ };} \\
	\hline
	\tcode{Data* data_;}
		& \tcode{std::atomic<Data*> data_;} \\
	\tcode{std::shared_mutex m_;}
		& \\
	\hline
	\tcode{template <typename Func>}
		& \tcode{template <typename Func>} \\
	\tcode{Result reader_op(Func fn) \{}
		& \tcode{Result reader_op(Func fn) \{} \\
	\tcode{  std::shared_lock<std::shared_mutex> l(m_);}
		& \tcode{  std::scoped_lock l(std::rcu_default_domain());} \\
	\tcode{  Data* p = data_;}
		& \tcode{  Data* p = data_;} \\
	\tcode{  // fn should not block too long or call update()}
		& \tcode{  // fn should not block too long or call} \\
		& \tcode{  // rcu_synchronize(), rcu_barrier(), or} \\
		& \tcode{  // rcu_retire(), directly or indirectly} \\
	\tcode{  return fn(p);}
		& \tcode{  return fn(p);} \\
	\tcode{\}}
		& \tcode{\}} \\
	\hline
	\tcode{// May be called concurrently with reader_op}
		& \tcode{// May be called concurrently with reader_op} \\
	\tcode{void update(Data* newdata) \{}
		& \tcode{void update(Data* newdata) \{} \\
	\tcode{  Data* olddata;}
		& \tcode{  Data* olddata = data_.exchange(newdata);} \\
	\tcode{  \{}
		& \\
	~~\tcode{    std::unique_lock<std::shared_mutex> wlock(m_);}
		& \\
	~~\tcode{    olddata = std::exchange(data_, newdata);}
		& \\
	\tcode{  \}}
		& \tcode{  std::rcu_synchronize(); // wait until it’s safe} \\
	\tcode{  delete olddata; // reclaim *olddata immediately}
		& \tcode{  delete olddata; // then reclaim *olddata} \\
	\tcode{\}}
		& \tcode{\}} \\
	\hline
\end{tabular}
\caption{Tony Table for Reader-Writer Locking and Synchronous RCU}
\label{tab:Tony Table for Reader-Writer Locking and Synchronous RCU}
\end{table*}

Table~\ref{tab:Tony Table for Reader-Writer Locking and Synchronous RCU}
compares reader-writer locking and synchronous RCU, that is, when the
RCU updater does an explicit wait for readers.
When using this style, RCU-protected data items need not inherit from
\tcode{std::rcu_obj_base<T>}.

\section{History}
\label{sec:History}

This paper is derived from N4895, which was in turn based on P1122R4.

P1122R4 is a successor to the RCU portion of P0566R5, in response to
LEWG’s Rapperswil 2018 request that the two techniques be split into
separate papers.

This is proposed wording for Read-Copy-Update [P0461], which is
a technique for safe deferred resource reclamation for optimistic
concurrency, useful for lock-free data structures.
Both RCU and hazard pointers have been progressing steadily through SG1
based on years of implementation by the authors, and are in wide use in
MongoDB (for Hazard Pointers), Facebook, and Linux OS (RCU).

We originally decided to do both papers' wording together to illustrate
their close relationship, and similar design structure, while hopefully
making it easier for the reader to review together for this first
presentation.
As noted above, they have been split on the committee's request.

This wording is based P0566r5, which in turn was based on that of on
n4618 draft [N4618].

\section{Source-Code Access}
\label{sec:Source-Code Access}

This section presents C++ reference implementations, other
C++ implementations, additional implementations and use cases,
and performance implications.

Counting the two reference implementation, this section points out
eleven implementations of RCU-like mechanisms in C++.

\subsection{Reference C++ Implementations}
\label{sec:Reference C++ Implementations}

The Folly library is open source, and its RCU implementation may be
accessed here:

\begin{itemize}
\item	https://github.com/facebook/folly/blob/main/folly/synchronization/Rcu.h
\item	https://github.com/facebook/folly/blob/main/folly/synchronization/Rcu-inl.h
\item	https://github.com/facebook/folly/blob/main/folly/synchronization/Rcu.cpp
\end{itemize}

There is an additional reference implementation of this proposal.
Unlike the Folly library's version, this reference implementation is
not production quality.
However, it is quite a bit simpler, having delegated the difficult parts
to the C-language userspace RCU library:

\begin{itemize}
\item	https://github.com/paulmckrcu/RCUCPPbindings/tree/master/Test/paulmck
\item	https://liburcu.org
\end{itemize}

\subsection{Other C++ Implementations}
\label{sec:Other C++ Implementations}

Maxim Khizhinsky added a C++ implementation of RCU to his libcds
around 2017.
URL: \url{https://github.com/khizmax/libcds/tree/master/cds/urcu}

Avi Kivity added a C++ implementation of RCU to the OSv kernel in
2010.
URL: \url{https://github.com/cloudius-systems/osv/blob/master/include/osv/rcu.hh}

Google uses an internally developed C++ RCU implementation alluded to by
Andrew Hunter's and Geoffrey Romer's P0561 C++ working paper.
This implementation makes use of restartable sequences in addition to
facilities defined in the standard.
URL: \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0561r4.html}

Isaac Gelado and Michael Garland describe use of a CUDA/C++ RCU in GPU
programming in their 2019 PPoPP paper entitled ``Throughput-Oriented
GPU Memory Allocation''.
URL: \url{https://dl.acm.org/doi/10.1145/3293883.3295727}
% Per email from Isaac Gelado on September 21, 2022.

M\'arton et al.~present a sample C++ implementation in their paper
entitled ``High-level C++ Implementation of the Read-Copy-Update
Pattern'', which appeared in the 2017 IEEE 14\textsuperscript{th}
International Scientific Conference on Informatics.
URL: \url{https://martong.github.io/high-level-cpp-rcu_informatics_2017.pdf}
The corresponding journal paper appeared in the September 2018 Acta
Electrotechnica et Informatica.

In 2016, Pedro Ramalhete and Andreia Correia produced a C++ prototype
implementation of RCU in the ConcurrencyFreaks GitHub repository.
URL: \url{https://github.com/pramalhe/ConcurrencyFreaks/tree/master/CPP/papers/gracesharingurcu}
This appeared in the August 2017 issue of ACM SIGPLAN Notices.
URL: \url{https://dl.acm.org/doi/abs/10.1145/3155284.3019021}

Peter Goodman produced a prototype C++ implementation of RCU in his
GitHub repository in 2012.
URL: \url{https://github.com/pgoodman/rcu}

StackExchange user Jamal posted a C++ RCU-like linked-list algorithm
in 2017.
URL: \url{https://codereview.stackexchange.com/questions/151936/rcu-in-c11-using-stdshared-ptr-and-a-little-more}.

Gamsa et al.~describe an RCU-like implementation within the Tornado
and K42 research operating systems, both of which were coded in C++.
Sections~5.2 and~5.3 of their 1999 OSDI paper entitled ``Tornado: Maximizing
Locality and Concurrency in a Shared Memory Multiprocessor Operating
System'' gives an overview of their RCU-like mechanism for providing
what they call ``existence guarantees''.
URL: \url{https://www.usenix.org/legacy/events/osdi99/full_papers/gamsa/gamsa.pdf}

There are implementations of RCU-like mechanisms in proprietary
applications, but these cannot be divulged to the committee without the
permission of their respective copyright holders.
However, in the words of Fedor Pikus:

\begin{quote}
	In fact, you may already be using the RCU approach in your program
	without realizing it! Wouldn't that be cool? But careful now:
	you may be already using the RCU approach in your program in a
	subtly wrong way. I'm talking about the kind of way that makes
	your program pass every test you can throw at it and then crash
	in front of your most important customer (but only when they
	run their most critical job, not when you try to reproduce
	the problem).
\end{quote}

URL: {\scriptsize \url{https://cppcon2017.sched.com/event/BgtF/read-copy-update-then-what-rcu-for-non-kernel-programmers}}

With these words, Fedor has pinpointed a major motivation for adding
RCU to the C++ standard: To provide a smaller number of known-good RCU
implementations to C++ users.

\subsection{Other Use Cases}
\label{sec:Other Use Cases}

The C-language userspace RCU library appeared around 2009.
The QEMU project created its own version of this library in 2015.
URL: \url{https://liburcu.org}

A list of additional RCU implementations in a variety of languages
may be found in Sections~9.5.5, 9.5.5.2, and~9.6.3.3 of
``Is Parallel Programming Hard, And, If So, What Can You Do About It?''.
URL: \url{https://kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook-e2.pdf}

RCU is used heavily in the Linux kernel:

\begin{enumerate}
\item	\url{http://www.rdrop.com/~paulmck/RCU/linuxusage.html}
\item	\url{http://www.rdrop.com/~paulmck/techreports/survey.2012.09.17a.pdf}
\item	\url{http://www.rdrop.com/~paulmck/techreports/RCUUsage.2013.02.24a.pdf}
\item	\url{https://dl.acm.org/doi/10.1145/3421473.3421481}
\end{enumerate}

\subsection{Performance Implications}
\label{sec:Performance Implications}

RCU provides the best results in read-mostly situations involving linked
data structures, and is most often used as a replacement for reader-writer
locking.
Experience in the Linux kernel indicates that well over half of the
situations to which reader-writer locking is applied can be handled
by RCU.
RCU has provided orders-of-magnitude performance and scalability
improvements in many situations, a few of which are listed below:

\begin{enumerate}
\item	\url{https://lwn.net/Kernel/Index/#Read-copy-update}
\item	\url{http://www2.rdrop.com/~paulmck/RCU/hart_ipdps06.pdf}
\item	\url{https://lkml.org/lkml/2004/8/20/137}
\item	\url{https://www.linuxjournal.com/article/7124}
\item	\url{https://www.linuxjournal.com/article/6993}
\item	\url{http://www2.rdrop.com/~paulmck/RCU/rcu.FREENIX.2003.06.14.pdf}
\item	\url{http://www2.rdrop.com/~paulmck/RCU/rcu.2002.07.08.pdf}
\item	\url{http://www2.rdrop.com/~paulmck/RCU/rclock_OLS.2001.05.01c.pdf}
\item	\url{https://docs.google.com/document/d/1X0lThx8OK0ZgLMqVoXiR4ZrGURHrXK6NyLRbeXe3Xac/edit?usp=sharing}
\end{enumerate}

Additional information may be found in Section~9.5.4 of the aforementioned
``Is Parallel Programming Hard, And, If So, What Can You Do About It?''.

\section{Acknowledgments}
\label{sec:Acknowledgments}

We owe special thanks to Jens Maurer, Arthur O'Dwyer, and Geoffrey Romer
for their many contributions to this effort.
